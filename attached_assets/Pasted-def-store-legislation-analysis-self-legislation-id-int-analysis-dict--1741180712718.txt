def _store_legislation_analysis(
        self, 
        legislation_id: int, 
        analysis_dict: Dict[str, Any]
    ) -> LegislationAnalysis:
        """
        Stores the analysis results in the database, creating a new LegislationAnalysis record
        and linking it to the previous version if it exists.
        """
        if not analysis_dict:
            raise ValidationError("Cannot store empty analysis data")

        with self._db_transaction():
            existing_analyses = self.db_session.query(LegislationAnalysis).filter_by(
                legislation_id=legislation_id
            ).all()

            if existing_analyses:
                prev = max(
                    existing_analyses,
                    key=lambda x: (
                        x.analysis_version if isinstance(x.analysis_version, int) else -1
                    ),
                    default=None
                )
                new_version = (
                    (prev.analysis_version or 0) + 1
                )
                prev_id = prev.id if prev else None
            else:
                new_version = 1
                prev_id = None

            impact_summary = analysis_dict.get("impact_summary", {})
            impact_category_str = impact_summary.get("primary_category")
            impact_level_str = impact_summary.get("impact_level")

            impact_category_enum = None
            impact_level_enum = None

            if impact_category_str is not None:
                try:
                    impact_category_enum = ImpactCategoryEnum(impact_category_str)
                except (ValueError, TypeError) as e:
                    logger.warning(
                        f"Invalid impact_category value: {impact_category_str}: {e}"
                    )
            if impact_level_str is not None:
                try:
                    impact_level_enum = ImpactLevelEnum(impact_level_str)
                except (ValueError, TypeError) as e:
                    logger.warning(
                        f"Invalid impact_level value: {impact_level_str}: {e}"
                    )

            analysis_obj = LegislationAnalysis(
                legislation_id=legislation_id,
                analysis_version=new_version,
                previous_version_id=prev_id,
                analysis_date=datetime.now(timezone.utc),
                summary=analysis_dict.get("summary", ""),
                key_points=analysis_dict.get("key_points", []),
                public_health_impacts=analysis_dict.get("public_health_impacts", {}),
                local_gov_impacts=analysis_dict.get("local_government_impacts", {}),
                economic_impacts=analysis_dict.get("economic_impacts", {}),
                environmental_impacts=analysis_dict.get("environmental_impacts", []),
                education_impacts=analysis_dict.get("education_impacts", []),
                infrastructure_impacts=analysis_dict.get("infrastructure_impacts", []),
                recommended_actions=analysis_dict.get("recommended_actions", []),
                immediate_actions=analysis_dict.get("immediate_actions", []),
                resource_needs=analysis_dict.get("resource_needs", []),
                raw_analysis=analysis_dict,
                model_version=self.config.model_name,
                impact_category=impact_category_enum,
                impact=impact_level_enum
            )

            # Optional: store some metadata
            if hasattr(analysis_obj, "processing_metadata"):
                analysis_obj.processing_metadata = {
                    "date_processed": datetime.now(timezone.utc).isoformat(),
                    "model_name": self.config.model_name,
                    "software_version": "2.0.0"
                }

            self.db_session.add(analysis_obj)
            logger.info(
                f"[AIAnalysis] Created new LegislationAnalysis "
                f"(version={new_version}) for Legislation {legislation_id}"
            )
            return analysis_obj